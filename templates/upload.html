<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Upload PDF</title><html>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>

    <div class="container-upload">
        {% include 'header.html' %}
        <h1>Upload de fichiers PDF</h1>

        <form id="uploadForm">
            <div id="dropzone" class="dropzone">D√©posez des fichiers PDF ici ou cliquez</div>
            <input type="file" id="fileInput" accept="application/pdf" multiple hidden>
            <ul id="fileList"></ul>
            <div class="button-group">
                <button type="button" class="btn-secondary" onclick="debugFiles()">Debug</button>
                <button type="button" class="btn-primary"onclick="uploadFiles()">Importer dans l'ERP</button>
            </div>
        </form>
        
    </div>

    <script>
        const dropzone = document.getElementById("dropzone");
        const fileInput = document.getElementById("fileInput");
        const fileList = document.getElementById("fileList");
        let selectedFiles = [];

        dropzone.addEventListener("click", () => fileInput.click());

        dropzone.addEventListener("dragover", (event) => {
            event.preventDefault();
            dropzone.classList.add("dragover");
        });

        dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));

        dropzone.addEventListener("drop", (event) => {
            event.preventDefault();
            dropzone.classList.remove("dragover");

            handleFiles(event.dataTransfer.files);
        });

        fileInput.addEventListener("change", () => {
            handleFiles(fileInput.files);
        });

        function handleFiles(files) {
            selectedFiles = Array.from(files).filter(file => file.type === "application/pdf");

            fileList.innerHTML = "";
            selectedFiles.forEach(file => {
                let li = document.createElement("li");
                li.textContent = file.name;
                fileList.appendChild(li);
            });

            if (selectedFiles.length === 0) {
                alert("Veuillez s√©lectionner uniquement des fichiers PDF.");
            }
        }

    function uploadFiles() {
        if (selectedFiles.length === 0) {
            alert("Aucun fichier s√©lectionn√©.");
            return;
        }

        let formData = new FormData();
        selectedFiles.forEach(file => formData.append("files", file));

        let uploadedFiles = [];

        // üîπ Affichage initial des fichiers avec ic√¥ne ‚è≥
        document.getElementById("fileList").innerHTML = selectedFiles
            .map((file, index) => `<li>${file.name} <span id="file-${file.name}" class="file-status pending">‚è≥</span></li>`)
            .join("");

        fetch("/upload", { method: "POST", body: formData })
            .then(response => response.json())
            .then(data => {
                if (data.files) {
                    uploadedFiles = data.files;  // ‚úÖ R√©cup√®re les noms des fichiers
                    checkProcessingStatus(uploadedFiles);  // ‚úÖ D√©marre la v√©rification en temps r√©el
                }
            })
            .catch(() => alert("Erreur lors du t√©l√©versement."));
    }

    // üîπ V√©rification dynamique des statuts
    function checkProcessingStatus(filenames) {
    let interval = setInterval(() => {
        if (filenames.length === 0) {
            clearInterval(interval);
            return;
        }

        fetch("/check_status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ filenames })
        })
        .then(response => response.json())
        .then(statusData => {
            let stillProcessing = [];

            filenames.forEach(filename => {
                let statusElement = document.getElementById(`file-${filename}`);
                if (!statusElement) return; // Ignore si l'√©l√©ment n'existe pas

                if (statusData[filename] === "done") {
                    statusElement.textContent = "‚úÖ";
                    statusElement.classList.remove("pending");
                    statusElement.classList.add("done");
                } else if (statusData[filename] === "error") {
                    statusElement.textContent = "‚ùå";
                    statusElement.classList.remove("pending");
                    statusElement.classList.add("error");
                } else {
                    stillProcessing.push(filename); // ‚úÖ On garde les fichiers qui sont encore en traitement
                }
            });

            if (stillProcessing.length === 0) {
                clearInterval(interval);
            } else {
                filenames = stillProcessing; // üî• Met √† jour la liste des fichiers en attente
            }
        });
    }, 2000); // V√©rification toutes les 1 seconde
}

    async function debugFiles() {
        await submitForm("/debug");
    }

    async function submitForm(action) {
        if (selectedFiles.length === 0) {
            alert("Aucun fichier s√©lectionn√©.");
            return;
        }

        let formData = new FormData();
        selectedFiles.forEach(file => formData.append("files", file));

        let response = await fetch(action, {
            method: "POST",
            body: formData
        });

        if (response.redirected) {
            window.location.href = response.url;  // üîÑ Redirection pour le Debug
        } else if (response.ok) {
            alert("Fichiers t√©l√©vers√©s avec succ√®s !");
            fileList.innerHTML = "";
            selectedFiles = [];
        } else {
            alert("Erreur lors du traitement !");
        }
    }
    </script>
</body>
</html>
